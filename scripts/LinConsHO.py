#!/usr/bin/env python
# coding: utf-8
'''
======================================================
Author:  Ömer Özak, 2013--2014 (ozak at smu.edu)
Website: http://omerozak.com
GitHub:  https://github.com/ozak/BoundedConsumption
======================================================
# This code generates the Value Functions generated by linear consumption rules for the analysis of the papers:
# 1. Howitt, Peter and Özak, Ömer, "Adaptive Consumption Behavior" Journal of Economic Dynamics and Control, 2014, Vol. 39: 37-61 (http://dx.doi.org/10.1016/j.jedc.2013.11.003)
# 2. Özak, Ömer, "Optimal consumption under uncertainty, liquidity constraints, and bounded rationality", Journal of Economic Dynamics and Control, 2014, Vol. 39: 237-254 (http://dx.doi.org/10.1016/j.jedc.2013.12.007)
# In particular, it computes optimal consumption when agent is liquidity constrained, income follows a 3-point iid process, CRRA coefficient is 3, and discount factor is 0.9 (as in Allen and Carroll) 
# These are baseline results and are the common specification in both these papers and in the Allen and Carroll paper.
# The program is not fully optimized. Instead it is written in order to maximize readibility, understanding, and replicability.
# It includes two ways of contructing the optimal policies and value functions.
# Should work on most Python distributions. Tested on Enthought Canopy 1.3, Python.org 2.7.6 + Numpy 1. + Scipy 1.10
# Feel free to use the code and play with parameters
# Author: Ömer Özak
# email: ozak (at) smu.edu
# Date: April 2013
'''
from __future__ import division
from scipy import linspace, mean, exp, randn 
from scipy.optimize import fminbound
from dynsys import *        # From listing 6.4
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm, lognorm
import time, sys, os
from itertools import product
import dynsysf

# Seed the random number generator
np.random.seed(100)

# Output directory
dir='../data/HOAC/'
if os.path.exists(dir[0:len(dir)-5])==False:
    os.mkdir(dir[0:len(dir)-5])
if os.path.exists(dir)==False:
    os.mkdir(dir)
fileopt=dir+'optcons.npz'
fileout=dir+'lincons'

# Let's replicate the Howitt Ozak (2014) parameter's
theta, beta= 3, 0.9                 # Preference Parameters
p=np.array([0.2, 0.6,0.2])          # Probability if income value i
y1=np.array([0.7,1,1.3])            # Income values
R=1                                 # Gross Interest rate

# auxiliary parameters and functions
theta1=1-theta
rho=beta
def phi(): return y1[sample(p)]    # Sample out of the income process

# Generate random sample of size 1000 from income process
y=np.array(y1[[sample(p) for i in range(1000)]])

# Parameters of the linear consumption functions
a=np.arange(0.01,2,0.01)       # Intercept
b=np.arange(0.01,1,0.01)       # MPC: Marginal propensity to consume out of wealth

# Grid of values for wealth over which function will be approximated
gridmax, gridsize = 5, 300
dx=0.01          # Gridcell size for pdf
grid = linspace(dx, gridmax**1e-1, gridsize)**10
wgrid=np.arange(0.1,gridmax,dx)

# Parameters for the optimization procedures
count=0
maxiter=1000
tol=1e-12
print 'tol=%1.10f' % tol

# Define CRRA Utility function 
def U(c,theta1):
    # CRRA Utility. theta1=1-theta 
    if theta1==0:
        return ln(c)
    else:
        return (c**theta1-1)/theta1 

# Wealth transition equation (s is savings in period t)
def f(s, y): return R*s+y     

# T operator
def T(sigma, w):
    """Implements the operator L T_sigma.
    For each policy sigma and 'Value' function, it returns a new Value function
    Used by function get_value(sigma,v) to generate the value function under sigma.
    """
    vals = []
    for W in grid:
        Tw_y = U(max(W - sigma(W),0),theta1) + rho * mean(w(f(sigma(W),y)))
        vals.append(Tw_y)
    return LinInterp(grid, vals)

# Value function of following policy sigma
def get_value(sigma, v):    
    """Computes an approximation to v_sigma, the value
    of following policy sigma. Function v is a guess.
    """
    tol_v = 1e-5         # Error tolerance 
    #counter=0
    while 1:#counter<maxiter:
        #counter+=1
        new_v = T(sigma, v)
        err_v = 2*beta/((1-beta)**2)*max(abs(new_v(grid) - v(grid)))
        if err_v < tol_v:
            return new_v
        v = new_v 
    '''if counter>maxiter:
        print 'Maximum iterations exceeded'
        return err'''           

# Consumption function as a function of intercept, MCP, and wealth
def c(w):
    '''Computes min(w,a0+a1*w)'''
    w=np.array(w)
    return np.where(w<=a0+w*a1,w,a0+w*a1)

# Saving function
def sigma(w):
    return w-c(w)

# Other functions
dF = lambda y, x: 1
t=1000

# Matrices for outputs
EV=np.zeros(shape=(len(a),len(b)))
Pstat=np.zeros(shape=(len(wgrid),len(a),len(b)))
V=np.zeros(shape=(len(wgrid),len(a),len(b)))

# Find Value Function for each linear consumption function
start=time.time()
for i,j in product(range(len(a)),range(len(b))):
    start2=time.time()
    a0=a[i]
    a1=b[j]
    v0=LinInterp(grid,U(c(grid),theta1))
    v1=get_value(sigma,v0)
    g = lambda x: R*sigma(x)                # Interest on savings
    F = lambda x, w : g(x)+w                # Wealth transition function
    Finv = lambda w, x: w-g(x)              # income level for given future wealth and current interest+savings
    Wealth_srs=SRS(F=F,phi=phi,X=np.random.permutation(wgrid)[0])   # Wealth stochastic dynamical system
    Pstat[:,i,j]=Wealth_srs.stationaryDist(n=t, FInv=Finv, dF=dF, phinv=dynsysf.phinv, dx=dx,xmin=0.1)  # Stationary distribution of wealth for each rule
    V[:,i,j]=v0(wgrid)                      # Value Function of rule
    EV[i,j]=np.dot(Pstat[:,i,j],V[:,i,j])   # Ex-ante Expected Utility in Steady State
    print(a0,a1)
    print('it took %2.2f seconds' %(time.time()-start2))
CE=(1+theta1*(1-beta)*EV)**(1/theta1)       # Certainty Equivalent
np.savez_compressed(fileout,EVlin=EV,CElin=CE,Pstat=Pstat,Vlin=V)
print('it took %2.2f seconds to do the whole job' %(time.time()-start))
